\chapter{Introduction}

Computer networking has a firm presence in many modern applications. Applications for social media, video streaming, and many other types of content rely on computer networking to serve content to the users of these types of applications. Whether the communication be via a server using the Hypertext Transfer Protocol (HTTP) or a server using the WebSocket Protocol (WebSockets), the common denominator is the Transmission Control Protocol (TCP) \cite{fielding1999hypertext}\cite{fette2011websocket}. As an underlying protocol to HTTP and WebSockets, TCP provides these higher level protocols, as well as other protocols that use TCP, reliability in communication and data integrity \cite{cerf1978specification}. These assurances offered by TCP have associated costs that directly impact transfer rate and network utilization, or bandwidth.

Many proposed methods for improving the transfer rate and network utilization include solutions like \cite{brakmo1995tcp}\cite{wei2006fast}\cite{xu2004binary}\cite{ha2008cubic} as well as others mentioned in \cite{ha2008cubic}\cite{He2002}. These solutions tend to focus on fine tuning TCP to use a large sliding window or change how the congestion control mechanism of TCP handles a packet loss event. As physical connections increase in bandwidth, fine tuning TCP may not be enough to improve performance, especially for connections that have large Round-Trip-Times (RTT) and/or under utilize bandwidth \cite{Fan2010} on network links like \cite{Pfister2001} and other Gigabit links.

A different approach has been to focus on creating new higher level protocols, or Application layer protocols. Works like \cite{Allman1995}\cite{Allman1997}\cite{Sivakumar2000psockets} used multiple TCP connections in parallel to try and improve performance without sacrificing reliability in communication. Parallelization poses two major challenges. The first is the additional work the application needs to do to handle multithreading in a way that addresses race conditions, deadlocks, and synchronicity. The second challenge is directly related to the degree of parallelism of a machine. For instance, if a machine has four hyperthreaded cores, it can support eight threads in parallel. In order to fully utilize the CPU, the application has to ensure that all eight threads are busy with work. If a thread goes idle, the application is not using the CPU to its fullest potential. Solutions that use parallelization may be able to improve bandwidth usage and transfer rate, but the shortcoming is under utilization of hardware rendering these solutions suboptimal.

Along with the use of parallel computing, there have been adaptations of the higher-level protocols and systems mentioned in \cite{Fan2010} that utilize UDP as the transport for packets from sender to receiver \cite{He2002}\cite{Fan2010}\cite{Aspera2016}\cite{Meiss2007}\cite{gu2007udt}. Using a UDP transport can be a viable method to mitigating under utilized networks. The reason for this is, unlike TCP, UDP does not employ any type of congrestion control or packet recovery \cite{postel1980user}. However, this means that in scenarios where the network is already congested, packets may be lost because UDP will attempt to send packets with no regard for the network conditions. Solutions like these that are UDP-based have to tackles the issue of communication reliability themselves. With increasing capabilities of physical connections with respect to bandwidth, a new challenge presents itself.

Aspera has noted that the challenge with Computer Networking is not so much with slow physical connections, but is instead with the end systems not being fast enough for the connection \cite{Fan2010}\cite{Aspera2016}. The path Aspera took involved building a custom end system that could operate faster to handle faster connections. The decision Aspera made begs the question, is it possible to achieve a faster end system by using a more generic technology?

This paper reviews an experimental protocol called Multi-Channel Data Transfer Protocol (MCDTP). The experimental protocol seeks to address the aforementioned question by using asynchrony. This report discusses the design of the protocol, the architecture of the implementation, the performances of MCDTP, and the challenges faced by this project. The goal of this project is to illustrate the effects of asynchrony with respect to data processing in the context of Computer Networking.
