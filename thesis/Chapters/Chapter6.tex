\chapter{Challenges and Future Work}\label{chp:c-fw}

\section{Challenges}

There were a number of challenges faced with this project. Some challenges derived from the language, others from poor design choices in early versions of MCDTP and MCDTPi. Challenges related to the language also related to the .NET Framework. The .NET Framework is transitioning to cross-platform support. Tooling targeted C\# first and F\# second. When a new pre-release was available of .NET Framework, now called .NET Core, F\# features would not always work and IDE support was spotty during the early pre-releases. It was not until recent that .NET Core stabilized and the F\# support became reliable. Additionally, many features found on Windows are not yet available on macOS or Linux. The development environment used for this project was macOS and the test environment Linux. This placed a hindrance on testing MCDTPi with performing I/O using no kernel buffering. Attempts at using native C to perform these actions was not fruitful due to the inability to link a C library to the F\# library. As a result, MCDTPi is currently confined to .NET Core in terms of platform specific feature support.

With respect to MCDTP and MCDTPi design challenges, early iterations had performance challenges. Some challenges were with the reactive programming. The built-in asynchronous feature in F\# is not sufficient for implementing reactive code. Early versions suffered from having stacking flush operations that would lead to a disk I/O operation blocking the next packet receive operation resulting in higher packet loss. This required restructuring MCDTPi to use reactive programming. Also, the design of MCDTP was affected by the poor structure. MCDTP was originally designed to use file checksumming to determine which portions of the file needed retransmission. However, this proved to be very inconsistent, partly due to the slowness, and was replaced with the $PacketManagement$ system discussed in section \ref{sec:pm-sm}.

\section{Future Work}

To focus on the experiment of MCDTP, a major feature left out, a user interface. However, as noted in section \ref{subsec:ftp-hs}, MCDTP was designed with extensibility in mind. MCDTP has a two-step handshake, one for specifications, another to prepare for an FTP session. A user interface can be injected between the two handshakes, which could either be a CLI or GUI. There is also room for this with the current MCDTPi. The API separates the two handshakes as separate functions opening the possibility for another process to happen. Adding this feature would increase usability.

The asynchronous tasking is an overhead that could be mitigated. Restructuring MCDTPi to more efficiently use asynchrony would reduce the performance impact of TPL. Asynchronous tasks would need to be used on packets in bulk rather than per packet. This is only applicable to MCDTPi. The .NET Framework handles sending packets asynchronously and thus is infeasible to modify. Another option would be to implement a custom asynchronous module that tries to mitigate the effects of using TPL. These options would need to be explored in separate work.

The data transmission phase could be optimized as well. As outlined in the design of MCDTP, a UDP packet can range from $13B \rightarrow 64KB$ in size. However, MCDTPi, is currently limited to $1500B$ in size. This is due to the MTU of the network. Packets larger in size are fragmented to fit this within this limit. This limitation effects bandwidth usage. To circumvent this, packets could be aggregated together to fit within the $64KB$ limit. Then, when a packet is fragmented, it is broken up into the smaller packets and thus maintaining data integrity. This would need to be tested in separate work to observe what performance gain may or may not occur.
