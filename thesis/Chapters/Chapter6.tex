\chapter{Challenges and Future Work}\label{chp:c-fw}

\section{Challenges}

There were a number of challenges faced with this project. Some challenges derived from the language, others from poor design choices in early versions of MCDTP and MCDTPi. Challenges related to the language also related to the .NET Framework. The .NET Framework is transitioning to cross-platform support. Tooling targeted C\# first and F\# second. When a new pre-release was available of .NET Framework, now called .NET Core, F\# features would not always work and IDE support was spotty during the early pre-releases. It was not until recent that .NET Core stabilized and the F\# support became reliable. Additionally, many features found on Windows are not yet available on macOS or Linux. The development environment used for this project was macOS and the test environment Linux. This placed a hindrance on testing MCDTPi with performing I/O using no kernel buffering. Attempts at using native C to perform these actions was not fruitful due to the inability to link a C library to the F\# library. As a result, MCDTPi is currently confined to .NET Core in terms of platform specific feature support.

With respect to MCDTP and MCDTPi design challenges, early iterations had performance challenges. Some challenges were with the reactive programming. The built-in asynchronous feature in F\# is not sufficient for implementing reactive code. Early versions suffered from having stacking flush operations that would lead to a disk I/O operation blocking the next packet receive operation resulting in higher packet loss. This required restructuring MCDTPi to use reactive programming. Also, the design of MCDTP was affected by the poor structure. MCDTP was originally designed to use file checksumming to determine which portions of the file needed retransmission. However, this proved to be very inconsistent, partly due to the slowness, and was replaced with the $PacketManagement$ system discussed in section \ref{sec:pm-sm}.

\section{Future Work}

To focus on the experiment of MCDTP, a major feature left out, a user interface. However, as noted in section \ref{subsec:ftp-hs}, MCDTP was designed with extensibility in mind. MCDTP has a two-step handshake, one for specifications, another to prepare for an FTP session. A user interface can be injected between the two handshakes, which could either be a CLI or GUI. There is also room for this with the current MCDTPi. The API separates the two handshakes as separate functions openning the possibility for another process to happen. Adding this feature would increase usability.

<fix me>

These proposed ideas need to be tested to see how performance is effected, whether it improves or degrades. This is left as future work for MCDTP.